<!DOCTYPE html>
<html>
  <head>
    <title>fishtron.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <style>
    </style>

    <script src="js/libs/jquery.js"></script>
    <script src="js/libs/underscore.js"></script>
    <!--<script src="js/libs/jquery.ui.js"></script>-->
    
<script>


$(function(){

  int  = mkAtm('int');
  char = mkAtm('char');

  x = mkVar('x',int);


  s = mkVal('s', mkTyp([int,int]) );

  f = mkLam(x, mkApp(s,x)  );

  one = mkVal(1,int);

  plus = mkVal( 'plus' , mkTyp([int,int,int])  );

  m = mkApp( f , one );

  //log( 'm = ' + code(m,'lc') );
  //log( 'm = ' + code(m,'jsstr') );


  g = mkVal( function(x){return x+1;} , mkArr(int,int) );

  ctx_ = {
   'plus' : { t : mkArr(int,mkArr(int,int))  
            , f : function(x){return function(y){return x+y;}; } },
   's'    : { t : mkArr(int,int)
            , f : function(x){return x+1;} }
  };

  ctx = mkCtx({
    '+' : [ [int,int,int]
        , function(x){return function(y){return x+y;}; }  ],
    's' : [ [int,int]
        , function(x){return x+1;} ]
  });


  ctx2 = mkCtx({
    'omg'  : [ [int,[int,int,int],[char,char],int]
             , function(x,y,z){return x;}  ],
    'plus' : [ [int,int,int]
           , function(x){return function(y){return x+y;}; }  ],
    's'    : [ [int,int]
           , function(x){return x+1;} ]
  });


  s0 = mkStartZipper(mkTyp([int,char,int]),ctx);
  log(showZipper(s0));
  s1 = expandLam(s0);
  log(showZipper(s1.zipper) + ' >>> dist=' + s1.dist );
  s2 = gotoNextUnf(s1.zipper);
  log(showZipper(s2));
  s3 = expandApp(s2);
  s4 = [];
  s5 = [];
  _.each(s3,function(z,i){
    s4[i] = z ;
    s5[i] = gotoNextUnf(z) ;
    log('  ' + showZipper(z));
    log('    ' + showZipper(s5[i]));
  });

  log('---------------------------');

  var logz = function(z){return log(showZipper(z))};

  z0 = mkStartZipperSmart( mkTyp([int,char,int]),ctx2 );
  logz( z0 );
  zs1 = smartExpand(z0);
  _.each(zs1,function(z,i){
    //z2[i] = z.zipper ;
    log('  ' + showZipper(z.state) + '  >>> dist=' + z.dist );
  });


  log('------------------------------');



  prove({
    n     : 500,
    typ   : mkTyp([int,int]),
    ctx   : ctx ,
    logit : true
  });


  
});


var prove = function(opts){
  if(opts === undefined){
    opts = {logit:true};
  } 

  var typ = opts.typ || mkTyp(['a','a']);
  var ctx = opts.ctx || mkCtx({});

  var ret = treeAStar({
    n     : opts.n     || 1,
    limit : opts.limit || 1000000,
    start : mkStartZipperSmart(typ,ctx),
    nexts : smartExpand,
    isGoal: function(zipper){return zipper.numUnfs === 0 ;},
    heur  : function(zipper){return zipper.numUnfs;}
  });  

  if( opts.logit ){
    _.each(ret,function(z,i){
      //log( i + ' : \t' + showZipper(z) );
      log( (i+1) + ' : \t' + code(gotoTop(z).act,'jsstr') );
    });  
  }

  return ret;
}




var mkAtm = function(a){
  return {
    c : 'atm' ,
    a : a
  };
};

var mkArr = function(a,b){
  return {
    c : 'arr',
    a : a,
    b : b
  };
};

var mkTyp = function( x ){
  if( _.isArray(x) ){
    var ts  = _.map( x , mkTyp );
    var acc = ts[ts.length-1];
    for( var i = ts.length-2 ; i >= 0 ; i-- ){
      acc = mkArr(ts[i],acc);
    }
    return acc;
  }else{
    if(_.isString(x)){
      return mkAtm(x);  
    }else{
      return x;
    }
  }
};

var tParts = function(t){
  assert( isTyp(t) , 'tParts: t must be typ.' );
  var ts = [];
  while( isArr(t) ){
    ts.push( t.a );
    t = t.b; 
  }
  return [ ts , t ];
};

var tHead = function(t){
  assert( isTyp(t) , 'tHead: t must be typ.' );
  while( isArr(t) ){ t = t.b; }
  return t;
};


var mkVar = function(x,t){
  return { 
    c : 'var',
    x : x    ,
    t : t
  };
};

var mkVal = function(x,t){
  return { 
    c : 'val',
    x : x    ,
    t : t
  };
};




var mkApp = function(m,n){

  assert( isArr( m.t ) );

  return { 
    c : 'app',
    m : m    ,
    n : n    ,
    t : m.t.b
  };
};


var mkLam_ = function(x,m,t){
  assert( _.isEqual( m.t , t.b )  );
  return { 
    c : 'lam',
    x : x    ,
    m : m    ,
    t : t
  };
};


var mkLam = function(x,y,z){
  return ( z ? mkLam_fromStr(x,y,z) 
             : mkLam_fromVar(x,y)   ) ;
};

var mkLam_fromStr = function(x,tx,m){
  return {
    c : 'lam', 
    x : x,
    m : m,
    t : mkArr( tx , m.t )
  };
};

var mkLam_fromVar = function(x,m){
  return {
    c : 'lam', 
    x : x.x,
    m : m,
    t : mkArr( x.t , m.t )
  };
};






var isArr    = function( x ){ return x.c === 'arr' ; };
var isAtm    = function( x ){ return x.c === 'atm' ; };
var isVar    = function( x ){ return x.c === 'var' ; };
var isVal    = function( x ){ return x.c === 'val' ; };
var isApp    = function( x ){ return x.c === 'app' ; };
var isLam    = function( x ){ return x.c === 'lam' ; };
var isUnf    = function( x ){ return x.c === 'unf' ; };
var isZipper = function( x ){ return x.c === 'zipper';};
var isTyp    = function( x ){ return isArr(x) || isAtm(x) ;};




var mkAtmTab = function(ctx){
  var ret = {};
  for( var i in ctx ){ 
    var alpha  = tHead( ctx[i].t ).a;
    if( ret[alpha] === undefined ){ ret[alpha] = {}; }  
    ret[alpha][i] = mkVal(i,ctx[i].t);
  }  
  return ret;
};

var atmTabToCtx = function(tab){
  var ret = {};
  for(var i in tab){
    for( var j in tab[i] ){
      ret[j] = {
        t : tab[i][j].t  ,
        f : undefined
      };
    }
  }
  return ret;
};

var showAtmTab = function(tab,opt){
  return showCtx( atmTabToCtx(tab) , opt );
};

var addVarToAtmTab = function(tab, newVar ){
  assert( isVar(newVar) , 'addVarToAtmTab : newVar must be var' );

  var ret   = _.clone(tab);
  var alpha = tHead(newVar.t).a;

  if( ret[alpha] === undefined ){ 
    ret[alpha] = {}; 
  } else {
    ret[alpha] = _.clone(ret[alpha]);
  } 

  ret[alpha][newVar.x] = newVar ;

  return ret;
};






var mkCtx = function(obj){
  var ctx = {};
  for( var i in obj ){
    var name = i;
    var typ  = mkTyp(obj[i][0]);
    var fun  = obj[i][1];
    ctx[name] = { 
      t : typ, 
      f : fun 
    };
  }
  return ctx;
};



var showCtx = function(ctx,opt){
  var isShort = opt === 'short';
  var ret = isShort ? '' : '\n';
  for(var i in ctx){
     ret += i ; 
     ret += isShort ? ',' : 
            ' : '+code(ctx[i].t)+'\n' ;
  }
  ret = isShort ? ret.substr(0,ret.length-1) : ret ;
  return ret;
};

var ctxCompile = function( m , ctx ){
  var ctxc = function(m){ 
    switch(m.c){
      case 'val' : 
        if( ctx[m.x] ){
          return mkVal( ctx[m.x].f , ctx[m.x].t );
        }else{
          return m;
        } 
      case 'var' : return m;
      case 'app' : return mkApp( ctxc(m.m) , ctxc(m.n) ) ;
      case 'lam' : 
        assert(isArr(m.t));
        return mkLam(m.x,m.t.a,ctxc(m.m));
    }
  }
  return code(ctxc(m));
};

var code = function(m,opt){
  if( isTyp(m) ){
    return typToStr(m);
  } else if( isZipper(m) ){
    return showZipper(m);
  } else if( _.isObject(opt) ) {
    return ctxCompile(m,opt);
  } else {
    switch( opt ){
      case 'js'    : return toJSexpr( m );
      case 'jsstr' : return toJSstr ( m );
      case 'lc'    : return toLCstr ( m );
      default      : return toJSexpr( m );
    }
  }
};



var typToStr = function(t){
  switch(t.c){
    case 'atm' : return t.a; 
    case 'arr' : return '(' + typToStr(t.a) + '->' + typToStr(t.b) + ')';
    default    : throw 'Unsupported type: ' + t
  }  
};


var toJSexpr = function(m){
  var result;
  var jsStr = 'result=' + toJSstr(m) + ';';
  eval(jsStr);
  return result; 
};

var toJSstr = function(m){
  switch(m.c){
    case 'val' : return m.x; 
    case 'var' : return m.x;
    case 'app' : return toJSstr(m.m) + '(' + toJSstr(m.n) + ')';
    case 'lam' : return 'function(' + m.x  + '){' +
                           'return ' + toJSstr(m.m) + ';}';
    case 'sex' : 
      var str = m.f +'(' ;
      for(var i=0;i<m.ms.length-1 ; i++ ){
        str += m.ms[i] + ','; 
      }
      str += m.ms[m.ms.length-1] + ')';
      return str;
    default    : throw 'Unsupported term structure (toJSstr).'
  }
};


var toLCstr = function(m){
  switch(m.c){
    case 'val' : return m.x; 
    case 'var' : return m.x;
    case 'app' : return '( '+ toLCstr(m.m) +' '+ toLCstr(m.n) +' )';
    case 'lam' : return '( '+ m.x +' . '+ toLCstr(m.m) +' )';
    case 'unf' : return '[' + code(m.t) +';'+ showAtmTab(m.atmTab,'short')+']';
    default    : throw 'Unsupported term structure (toLCstr).'
  }
};


var log = function(x){
  return console.log(x);
};

var assert = function(condition, message) {
  if (!condition) {
    throw message || "Assertion failed!";
  }
};



//----------------------------------------------------


var mkSex = function(f,ms,t){
  return { c  : 'sex'
         , f  : f 
         , ms : ms 
         , t  : t  };
};


var mkSexpr = function(f,ms){

  var parts = tParts(f.t);
  var ts    = parts[0];
  var alpha = parts[1]; 

  assert( ts.length === ms.length , 
    'mkSexpr : lengths dont match' );
  
  var acc = f ;

  for( var i = 0 ; i < ms.length ; i++ ){
    assert( _.isEqual( ts[i] , ms[i].t ) ,
      'mkSexpr : types are not equal' );
    
    acc = mkApp( acc , ms[i] );
  }

  return acc;
};



var mkAppLZ = function(m){
  assert( isApp(m) , 'Error in mkAppLZ!');
  return {
    c : 'appLZ' ,
    n : m.n ,
    t : m.t 
  };
};

var mkAppRZfromLZ = function(lz,m){
  assert( lz.c === 'appLZ' );
  return {
    c : 'appRZ' ,
    m : m ,
    t : lz.t 
  };
};

var mkLamZ = function(m){
  assert( isLam(m) , 'Error in mkLamZ!');
  return {
    c : 'lamZ',
    x : m.x ,
    t : m.t
  };
};




var empty = null;
var cons = function(x,xs){
  return { head : x  , 
           tail : xs };
};




var showZipper = function(zipper){
  if( zipper === null ){ return '[NULL ZIPPER]'}
  assert( isZipper(zipper) , 'showZipper : it is not a zipper' );
  var show = function( zips , str ){
    if( !zips || !zips.head ){ return str; }
    switch( zips.head.c ){
      case 'lamZ'  :
        return show( zips.tail , 
          '( ' + zips.head.x + ' . ' + str + ')'  );
      case 'appLZ' :
        return show( zips.tail ,
          '( '+ str +' '+ code(zips.head.n,'lc') +' )' );
      case 'appRZ' : 
        return show( zips.tail ,
          '( '+ code(zips.head.m,'lc') +' '+ str +' )' );
    }
  };
  return show( zipper.zips , 
               ' { ' + code(zipper.act,'lc') + ' } ' ) + '   ['+ zipper.numUnfs +']';
};

var mkZipper = function(obj,parentZipper){

  var pz = function(prop,defa){
    if( obj[prop] !== undefined ){ return obj[prop];} 
    else if( parentZipper )      { return parentZipper[prop];} 
    else                         { return defa ;}
  };

  return {
    c       : 'zipper' ,
    act     : pz('act'),
    zips    : pz('zips',empty),
    nextVar : pz('nextVar',0),
    numUnfs : pz('numUnfs',0)
  };
};










var expandLam = function( zipper ){
  assert( isUnf(zipper.act) , 
          'act must be unf to be lam-expanded' );

  var t         = zipper.act.t;
  var newAtmTab = zipper.act.atmTab; 
  var varI      = zipper.nextVar; 
  var newVars   = [];


  assert( isArr(t), 'Lam-expanded can be only arrow type.' );

  
  while( isArr(t) ){
    var newVar = mkVar( '_'+varI , t.a );
    newVars.push(  newVar  );
    newAtmTab = addVarToAtmTab( newAtmTab , newVar );

    varI ++;
    t = t.b;
  }

  var acc = mkUnf( t , newAtmTab );

  for( var i = newVars.length-1 ; i >= 0 ; i-- ){
    acc = mkLam( newVars[i] , acc );
  }

  return {
    zipper : mkZipper({
               act     : acc,
               nextVar : varI 
             },zipper),
    dist   : newVars.length 
  };  
};


var expandApp = function( zipper ){
  assert( isUnf(zipper.act) , 
          'act must be unf to be app-expanded' );

  var typ    = zipper.act.t;
  var atmTab = zipper.act.atmTab;

  assert( isAtm(typ), 'App-expanded can be only atomic type.' );

  var ret = [];

  var row = atmTab[typ.a];
  if( row !== undefined ){
    for( var i in row ){

      var ms = _.map( tParts(row[i].t)[0] , function(t){
        return mkUnf(t,atmTab);
      });
      
      ret.push(mkZipper({
        act     : mkSexpr(row[i],ms),
        numUnfs : zipper.numUnfs - 1 + ms.length 
      },zipper));

    }
  }

  return ret;

};

var smartExpand = function( zipper ){
  assert( isUnf(zipper.act) , 'smartExpand : act must be unf to be smart-expanded'+
  '\n zipper : '+ showZipper(zipper) );

  var typ    = zipper.act.t;
  var atmTab = zipper.act.atmTab;

  assert( isAtm(typ), 'smartExpand : Smart-expanded can be only atomic type.' );

  var ret = [];

  var row = atmTab[typ.a];
  if( row !== undefined ){
    for( var i in row ){

      var varI = zipper.nextVar; 

      var ms = _.map( tParts(row[i].t)[0] , function(t){

        var newAtmTab = atmTab;   
        var newVars   = [];

        while( isArr(t) ){
          var newVar = mkVar( '_'+varI , t.a );
          newVars.push(newVar);
          newAtmTab = addVarToAtmTab(newAtmTab,newVar);
      
          varI ++;
          t = t.b;
        }
      
        var acc = mkUnf(t,newAtmTab);
      
        for( var i = newVars.length-1 ; i >= 0 ; i-- ){
          acc = mkLam( newVars[i] , acc );
        }

        return acc;
      });
      
      var newNumUnfs = zipper.numUnfs - 1 + ms.length ;

      var newZipper  = mkZipper({
                          act     : mkSexpr(row[i],ms),
                          numUnfs : newNumUnfs, 
                          nextVar : varI  
                       },zipper);

      if( newNumUnfs !== 0 ){
        newZipper = gotoNextUnf( newZipper );
      }


      ret.push({
        state : newZipper,
        dist  : 1 + (varI-zipper.nextVar) 
      });

    }
  }

  return ret;

};

var gotoTop = function( zipper ){
  while( zipper.zips ){
    zipper = goUp(zipper);
  }
  return zipper;
};

var goUp = function( zipper ){
  assert( zipper.zips , 'goUp : impossible to go up ' );
  var headZip = zipper.zips.head ;
  assert( headZip , 'goUp : incorrect headZip..' );

  switch( headZip.c ){
    case 'appLZ' : return mkZipper({
        act  : mkApp( zipper.act , headZip.n ) ,
        zips : zipper.zips.tail
      },zipper);
    case 'appRZ' : return mkZipper({
        act  : mkApp( headZip.m , zipper.act ),
        zips : zipper.zips.tail 
      },zipper);
    case 'lamZ' : return mkZipper({ 
        act  : mkLam_( headZip.x , zipper.act , headZip.t ),
        zips : zipper.zips.tail 
      },zipper);
    default : throw "Unsupported zip constructor."
  }
};

var gotoNextUnf = function( zipper ){
  while( zipper !== null && ! isUnf(zipper.act) ){
    zipper = dfsStep(zipper);
  }
  return zipper;
};

var dfsStep = function( zipper ){
  switch( zipper.act.c ){
    case 'app' :
      return mkZipper({ 
        act  : zipper.act.m ,
        zips : cons( mkAppLZ(zipper.act) , zipper.zips ) 
      },zipper);
    case 'lam' :
      return mkZipper({
        act  : zipper.act.m ,
        zips : cons( mkLamZ(zipper.act) , zipper.zips )
      },zipper);
    default : return stepToNextBigger( zipper );
  }
};

var stepToNextBigger = function( zipper ){
  if( !zipper.zips ){ return null; }
  var headZip = zipper.zips.head ;
  if( !headZip ){ return null; }

  switch( headZip.c ){
    case 'appLZ' :
      return mkZipper({
        act  : headZip.n ,
        zips : cons( mkAppRZfromLZ(headZip,zipper.act)  
                   , zipper.zips.tail ) 
      },zipper);
    case 'appRZ' :
      return stepToNextBigger(mkZipper({
        act  : mkApp( headZip.m , zipper.act ),
        zips : zipper.zips.tail 
      },zipper));
    case 'lamZ'  :
      return stepToNextBigger(mkZipper({ 
        act  : mkLam_( headZip.x , zipper.act , headZip.t ),
        zips : zipper.zips.tail 
      },zipper));
    default : throw "Unsupported zip constructor."
  }

};




var mkStartZipper = function(t,ctx){
  return mkZipper({ 
        act     : mkUnf(t, mkAtmTab(ctx) ) ,
        zips    : empty,
        numUnfs : 1  
  });
};

var mkStartZipperSmart = function(t,ctx){
  var zipper = mkZipper({ 
        act     : mkUnf(t, mkAtmTab(ctx) ) ,
        zips    : empty,
        numUnfs : 1  
  });

  if( isArr(t) ){
    zipper = gotoNextUnf(expandLam(zipper).zipper);
  }

  return zipper;
};


var mkUnf = function(t,atmTab){
  return { c       : 'unf'
         , t       : t
         , atmTab  : atmTab };
};




var mkPrioQueue = function(){
  return [];
}; 

var prioPush = function( queue , x , val ){
  var newEntry = [x,val];
  var i = _.sortedIndex(queue,newEntry,function(pair){return pair[1];});
  queue.splice(i,0,newEntry);
}

var prioPop = function( queue ){
  return queue.shift();
}

var isPrioEmpty = function( queue ){
  return queue.length === 0;
};

logPrio = function(queue,showFun){
  if(showFun === undefined){
    showFun = function(x){return x;}; 
  }

  _.each(queue,function(pair){
    log( pair[1] +' : '+ showFun(pair[0]) );
  });
};





var treeAStar = function(problem){

  var start  = {s:problem.start,G:0} ;
  var nexts  = problem.nexts  ;
  var isGoal = problem.isGoal ;
  var n      = problem.n      || 1;
  var heur   = problem.heur   || function(x){return 0;};
  var limit  = problem.limit  || 1000000;

  var q = mkPrioQueue(); 
  var results = [];

  prioPush( q , start , heur(start.s) );

  while( !isPrioEmpty(q) && limit > 0 ){
      
    limit--;

    var st    = prioPop(q)[0];
    var state = st.s    ;
    var G     = st.G    ;
    //log( 'vyndavam : ' + showZipper(state) );

    if( isGoal(state) ){
      results.push(state);
      if( results.length == n ){
        return results;
      }
    } else { // TODO : obecně to ale pro grafovej Astrar neplatí
             // (to že je to v else) prorože i za cílovym může bejt 
             // další cílovej, u nás toé ale tak rozhodně neni a tak si to dovolíme
             // vlastně se jedná o treeAStar-s-goalama-v-listech-tho-tree

      var ns = nexts(state);
      for( var i = 0 ; i < ns.length ; i++ ){
        
        var newG = G + ns[i].dist ;
  
        var next = {s : ns[i].state ,
                    G : newG  };
        
        //log( '  vkladam : ' + showZipper(ns[i].state) );
        prioPush( q , next , newG + heur(next.s) ); 
      }

    }

  }
  return results;
};



/* /
$(function(){


  sumStr = function(str){
    var sum = 0;
    for( var i = 0 ; i < str.length ; i++ ){
      sum += parseInt(str[i]);
    }
    return sum;
  };

  res = treeAStar({
    n     : 100 ,
    start : '' ,
    isGoal: function(x){
              return sumStr(x) == 10;} ,
    nexts : function(x){
              return [ {state:x+'0',dist:1} ,
                       {state:x+'1',dist:1} ]; },
    heur  : function(x){
              return Math.max( 0 , 10 - sumStr(x) );}
  });  




});
/ */




</script>
</head>
<body>
</body>
</html>



